chaque livre “acheté” doit être servi via un jeton (token) émis par VISUAL, jamais par une URL publique.
Ce jeton sert à (1) prouver la licence de l’investi-lecteur, (2) générer une URL signée courte durée vers le fichier source (CDN/stockage), et (3) journaliser l’usage (anti-abus).

Comment on le fait proprement
1) Jeton de licence (JWT, côté VISUAL)

Format : JWT RS256 (clé privée côté serveur), 10 min de TTL, usage unique (jti enregistré pour éviter la relecture).

Claims typiques :

sub = user_id, book_id, order_id

exp (expiration), nbf (not before)

dl_max (téléchargements restants), device/ip_hash (optionnel)

wm (infos watermark : id, email hash, date)

Émis après paiement réussi (Stripe webhook) → stocké dans la “bibliothèque” de l’utilisateur.

2) Échange jeton → URL signée (download)

Le front appelle GET /api/livres/{bookId}/download?lic=JWT.

Le backend vérifie le JWT, vérifie quotas et statut licence, journalise (audit HMAC).

Il génère une URL signée courte durée (ex. 30–60 s) côté CDN/stockage (Bunny/S3/CloudFront) et redirige 302.

Résultat : aucune URL longue durée n’est exposée, et chaque clic est tracé/limité.

3) Watermark personnalisé (anti-partage)

PDF : overlay texte discret (nom ou email hash + order_id + date) dans le pied de page, + watermark invisible (empreinte/ID) si possible.

EPUB : injection d’un petit chapitre “Licence” + métadonnées custom (ID de licence).

Option “lecture en ligne” : viewer web (PDF.js / EPUB.js) avec token au lieu de fichier brut.

4) Quotas & anti-abus

Rate-limit par licence (ex. 3 téléchargements sur 7 jours).

“Step-up” (re-vérif 2FA) pour ré-obtenir un lien si l’activité paraît suspecte.

Révocation automatique si remboursement/chargeback.

5) Juridique & UX

CGU : licence strictement personnelle, pas de redistribution.

Page “Mes livres” : bouton Télécharger et Lire dans le navigateur (recrée une URL signée à chaque clic).

Accessibilité : conserver un chemin pour lecteurs d’écran (pas de DRM bloquant l’accessibilité).

Exemple FastAPI (minimal)
# server/routes/books_download.py
from fastapi import APIRouter, HTTPException, Response
from fastapi.responses import RedirectResponse
import time, os, jwt  # pyjwt
from server.audit.ledger import append_audit

router = APIRouter(prefix="/api/livres", tags=["livres"])

PUB_KEY = os.getenv("JWT_PUBKEY")  # RS256 public
CDN_SIGN_KEY = os.getenv("CDN_SIGN_KEY")  # clé pour URL signée (selon ton CDN)

def verify_and_consume_license(jwt_token: str):
    try:
        claims = jwt.decode(jwt_token, PUB_KEY, algorithms=["RS256"], options={"require": ["exp","sub"]})
    except Exception:
        raise HTTPException(401, "Licence invalide/expirée")
    # TODO: vérifier jti non déjà utilisé, quotas dl_max > 0, statut licence en DB
    return claims  # {sub, book_id, order_id, ...}

def sign_cdn_url(path: str, ttl_sec=60) -> str:
    # TODO: implémentation propre à ton CDN (Bunny/S3/CloudFront…)
    # Ici on simule une URL signée courte durée
    exp = int(time.time()) + ttl_sec
    token = "signature..."  # à calculer selon la doc CDN
    return f"https://cdn.visual.example{path}?expires={exp}&token={token}"

@router.get("/{book_id}/download")
def download_book(book_id: str, lic: str):
    c = verify_and_consume_license(lic)
    if c.get("book_id") != book_id:
        raise HTTPException(403, "Licence non valide pour ce livre")
    # Option: générer à la volée un PDF watermarké et le pousser côté stockage
    # path = f"/books/{book_id}/{c['order_id']}.pdf"
    path = f"/books/{book_id}/master.pdf"  # si watermark en amont
    url = sign_cdn_url(path, ttl_sec=60)
    append_audit("book_download", c["sub"], {"book_id": book_id, "order_id": c["order_id"]})
    return RedirectResponse(url, status_code=302)


Variante “lecture en ligne” : la même route sert un token de lecture pour le viewer, mais jamais le fichier brut.

Checklist “Livres” (à coller dans ta roadmap)

 Émettre JWT licence (RS256) via webhook Stripe “paiement confirmé”.

 Endpoint /download qui échange le JWT contre une URL signée (60 s).

 Watermark PDF/EPUB (visible + invisible).

 Quotas (3 DL / 7 jours) + revocation si remboursement.

 Audit HMAC des téléchargements.

 Viewer en ligne tokenisé (option).

 CGU : licence personnelle, pas de diffusion.

Règle simple (par défaut)

Téléchargements autorisés : 3 tentatives / 7 jours / livre / compte.

Jeton court-terme, usage unique : chaque clic régénère une nouvelle URL signée (TTL 60–120 s).

Grâce auto en cas de bug : si la tentative n’a pas été confirmée côté serveur/CDN, elle ne consomme pas le quota (l’utilisateur peut relancer immédiatement).

Ces seuils sont configurables (ex. 2–5 tentatives, fenêtre 7–30 jours).

Comment on l’assure techniquement

Jeton licence (JWT) → /api/livres/{id}/download?lic=…

Vérif licence + création d’une “tentative PENDING” avec expires_at = now + 2 min.

Génération URL signée (60–120 s) et redirige 302.

Confirmation “succès” :

idéal : via logs CDN (accès 200 sur l’URL signée/nonce),

ou via un beacon chargé par une petite page d’interstice (/download/start) qui lance le fichier + ping /download/mark?rid=….

Débit du quota uniquement si la tentative passe en SUCCESS avant expires_at + marge (ex. +60 s).

Si pas de preuve → la tentative retombe en EXPIRED ⇒ quota non débité ⇒ l’utilisateur peut réessayer.

Bouton “Réessayer” dans “Mes livres” : régénère un lien sans contact support tant qu’il reste des tentatives.

Secours : si quota épuisé mais incident détecté (logs d’erreur, 5xx), crédit auto d’1 tentative ou bouton “Demander un nouveau lien” (workflow support).

Mini-schéma (DB)
licenses(id, user_id, book_id, dl_limit=3, window_days=7, dl_used, window_start_at)
dl_attempts(id, license_id, status=PENDING|SUCCESS|EXPIRED, created_at, expires_at, nonce)

Pseudocode FastAPI (condensé)
# Lors du /download :
attempt = create_attempt(license_id, status="PENDING", expires=now+120s, nonce=rand())
url = sign_cdn_url(path=f"/books/{book}.pdf", nonce=attempt.nonce, ttl=60)
return RedirectResponse(url, 302)

# Tâche de confirmation (cron/webhook CDN/logs) :
if cdn_logs.has_200_for(nonce) or beacon_hit(nonce):
    mark_success(attempt); increment_quota(license)
else if now > attempt.expires_at + 60s:
    mark_expired(attempt)  # quota NON débité

UX côté utilisateur

“Télécharger” → si échec → “Réessayer” (immédiat).

Si toutes les tentatives consommées : “Demander un nouveau lien” (auto-crédit si erreur serveur détectée, sinon support).

Mail “Votre lien est prêt” avec rappel : lien temporaire, strictement personnel.